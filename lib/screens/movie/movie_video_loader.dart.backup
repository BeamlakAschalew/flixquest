// ignore_for_file: use_build_context_synchronously
import 'package:flixquest/functions/function.dart';
import 'package:flixquest/functions/network.dart';
import 'package:flixquest/functions/video_utils.dart';
import 'package:flixquest/models/movie_stream_metadata.dart';
import 'package:flixquest/models/provider_load_state.dart';
import 'package:flixquest/services/globle_method.dart';
import 'package:flixquest/video_providers/provider_loader.dart';
import 'package:flixquest/widgets/provider_loading_widget.dart';
import '../../controllers/recently_watched_database_controller.dart';
import '../../provider/recently_watched_provider.dart';
import '../../video_providers/common.dart';
import '../../video_providers/names.dart';
import '/api/endpoints.dart';
import '/provider/app_dependency_provider.dart';
import '/provider/settings_provider.dart';
import 'package:easy_localization/easy_localization.dart';
import 'package:provider/provider.dart';
import 'package:better_player_plus/better_player.dart';
import '../../models/sub_languages.dart';
import '../../widgets/common_widgets.dart';
import '/constants/app_constants.dart';
import 'package:flutter/material.dart';
import '../../screens/common/player.dart';

class MovieVideoLoader extends StatefulWidget {
  const MovieVideoLoader(
      {required this.download,
      required this.metadata,
      required this.route,
      super.key});

  final bool download;
  final MovieStreamMetadata metadata;
  final StreamRoute route;

  @override
  State<MovieVideoLoader> createState() => _MovieVideoLoaderState();
}

class _MovieVideoLoaderState extends State<MovieVideoLoader> {
  RecentlyWatchedMoviesController recentlyWatchedMoviesController =
      RecentlyWatchedMoviesController();

  List<RegularVideoLinks>? movieVideoLinks;
  List<RegularSubtitleLinks>? movieVideoSubs;

  late SettingsProvider settings =
      Provider.of<SettingsProvider>(context, listen: false);
  late AppDependencyProvider appDep =
      Provider.of<AppDependencyProvider>(context, listen: false);
  List<VideoProvider> videoProviders = [];
  late SettingsProvider prefString =
      Provider.of<SettingsProvider>(context, listen: false);

  List<ProviderLoadState> providerStates = [];
  int currentProviderIndex = 0;

  Map<String, String> videos = {};
  List<BetterPlayerSubtitlesSource> subs = [];

  late int foundIndex;

  @override
  void initState() {
    super.initState();
    videoProviders.addAll(
        parseProviderPrecedenceString(prefString.proPreference)
            .where((provider) => provider != null)
            .cast<VideoProvider>());
    
    // Initialize provider states
    for (var provider in videoProviders) {
      providerStates.add(ProviderLoadState(
        codeName: provider.codeName,
        fullName: provider.fullName,
        status: ProviderStatus.pending,
      ));
    }
    
    loadVideo();
  }

  void loadVideo() async {
    try {
      // Fetch movie recommendations first
      await _fetchMovieRecommendations();

      var isBookmarked = await recentlyWatchedMoviesController
          .contain(widget.metadata.movieId!);
      int elapsed = 0;
      if (isBookmarked) {
        var rMovies =
            Provider.of<RecentProvider>(context, listen: false).movies;
        int index = rMovies
            .indexWhere((element) => element.id == widget.metadata.movieId);
        setState(() {
          elapsed = rMovies[index].elapsed!;
        });
        widget.metadata.elapsed = elapsed;
      } else {
        widget.metadata.elapsed = 0;
      }
      
      if (widget.metadata.releaseDate != null &&
          !isReleased(widget.metadata.releaseDate!)) {
        GlobalMethods.showScaffoldMessage(
            tr('movie_may_not_be_available'), context);
      }

      // Iterate through providers
      for (int i = 0; i < videoProviders.length; i++) {
        if (mounted) {
          setState(() {
            currentProviderIndex = i;
            providerStates[i] = providerStates[i].copyWith(
              status: ProviderStatus.loading,
            );
          });
        }

        try {
          final result = await ProviderLoader.loadMovieFromProvider(
            providerCode: videoProviders[i].codeName,
            route: widget.route,
            movieId: widget.metadata.movieId!,
            movieName: widget.metadata.movieName!,
            releaseYear: widget.metadata.releaseYear,
            consumetUrl: appDep.consumetUrl,
            newFlixHQUrl: appDep.newFlixHQUrl,
            flixApiUrl: appDep.flixApiUrl,
            newFlixhqServer: appDep.newFlixhqServer,
            streamingServerFlixHQ: appDep.streamingServerFlixHQ,
            streamingServerDCVA: appDep.streamingServerDCVA,
            streamingServerZoro: appDep.streamingServerZoro,
          );

          if (result.success &&
              result.videoLinks != null &&
              result.videoLinks!.isNotEmpty) {
            // Success! Mark provider as successful
            if (mounted) {
              setState(() {
                providerStates[i] = providerStates[i].copyWith(
                  status: ProviderStatus.success,
                );
                movieVideoLinks = result.videoLinks;
                movieVideoSubs = result.subtitleLinks;
              });
            }

            // Convert and process videos
            videos = VideoUtils.convertVideoLinksToMap(movieVideoLinks!);

            // Process subtitles if available
            if (movieVideoSubs != null && movieVideoSubs!.isNotEmpty) {
              await _processSubtitles(movieVideoSubs!);
            }

            break; // Found working provider, exit loop
          } else {
            // Provider failed
            if (mounted) {
              setState(() {
                providerStates[i] = providerStates[i].copyWith(
                  status: ProviderStatus.failed,
                  errorMessage: result.errorMessage ?? 'No video sources found',
                );
              });
            }
          }
        } catch (e) {
          // Provider error
          if (mounted) {
            setState(() {
              providerStates[i] = providerStates[i].copyWith(
                status: ProviderStatus.failed,
                errorMessage: e.toString(),
              );
            });
          }
        }
      }

      // Check if we found any working provider
      if ((movieVideoLinks == null || movieVideoLinks!.isEmpty) && mounted) {
        Navigator.pop(context);
        showModalBottomSheet(
            builder: (context) {
              return ReportErrorWidget(
                error: tr('movie_vid_404'),
                hideButton: false,
              );
            },
            context: context);
        return;
      }

      // Prepare final video map (reversed for quality ordering)
      Map<String, String> reversedVids = VideoUtils.reverseVideoQualityMap(videos);

      if (movieVideoLinks != null && mounted) {
        final mixpanel =
            Provider.of<SettingsProvider>(context, listen: false).mixpanel;
        mixpanel.track('Most viewed movies', properties: {
          'Movie name': widget.metadata.movieName,
          'Movie id': widget.metadata.movieId,
          'Is Movie adult?': widget.metadata.isAdult ?? 'unknown',
        });

        // Navigate to player
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(
            builder: (context) {
              return PlayerOne(
                mediaType: MediaType.movie,
                sources: reversedVids,
                subs: subs,
                colors: [
                  Theme.of(context).primaryColor,
                  Theme.of(context).colorScheme.surface
                ],
                settings: settings,
                movieMetadata: widget.metadata,
                subtitleStyle:
                    Provider.of<SettingsProvider>(context).subtitleTextStyle,
              );
            },
          ),
        ).then((value) async {
          if (value != null) {
            Function callback = value;
            await callback.call();
          }
        });
      } else {
        if (mounted) {
          Navigator.pop(context);
          showModalBottomSheet(
              builder: (context) {
                return ReportErrorWidget(
                  error: tr('movie_vid_404'),
                  hideButton: false,
                );
              },
              context: context);
        }
      }
    } on Exception catch (e) {
      if (mounted) {
        Navigator.pop(context);
        showModalBottomSheet(
            builder: (context) {
              return ReportErrorWidget(
                error: "${tr("movie_vid_404")}\n$e",
                hideButton: false,
              );
            },
            context: context);
      }
    }
  }

  void getAppLanguage() {
    for (int i = 0; i < supportedLanguages.length; i++) {
      if (supportedLanguages[i].languageCode ==
          settings.defaultSubtitleLanguage) {
        foundIndex = i;
        break;
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: ProviderLoadingWidget(
          providers: providerStates,
          currentIndex: currentProviderIndex,
        ),
      ),
    );
  }

  Future<void> _processSubtitles(List<RegularSubtitleLinks> subtitles) async {
    getAppLanguage();
    final isProxyEnabled =
        Provider.of<SettingsProvider>(context, listen: false).enableProxy;
    final appDep = Provider.of<AppDependencyProvider>(context, listen: false);
    
    try {
      if (!appDep.fetchSubtitles) {
        return;
      }

      // Use the VideoUtils.parseSubtitles method
      final parsedSubs = await VideoUtils.parseSubtitles(
        subtitles: subtitles,
        defaultLanguage: settings.defaultSubtitleLanguage.isEmpty
            ? ''
            : supportedLanguages[foundIndex].englishName.isEmpty
                ? ''
                : supportedLanguages[foundIndex].languageCode,
        fetchAllLanguages: settings.fetchSpecificLangSubs,
        getVttContent: (url) => getVttFileAsString(url),
      );

      if (mounted) {
        setState(() {
          subs.addAll(parsedSubs);
        });
      }

      // Handle external subtitles if needed
      if (parsedSubs.isEmpty && appDep.useExternalSubtitles) {
        await fetchSocialLinks(
          Endpoints.getExternalLinksForMovie(
              widget.metadata.movieId!, settings.appLanguage),
          isProxyEnabled,
          appDep.tmdbProxy,
        ).then((value) async {
          if (value.imdbId != null) {
            await getExternalSubtitle(
                    Endpoints.searchExternalMovieSubtitles(value.imdbId!,
                        supportedLanguages[foundIndex].languageCode),
                    appDep.opensubtitlesKey)
                .then((value) async {
              if (value.isNotEmpty &&
                  value[0].attr!.files![0].fileId != null) {
                await downloadExternalSubtitle(
                        Endpoints.externalSubtitleDownload(),
                        value[0].attr!.files![0].fileId!,
                        appDep.opensubtitlesKey)
                    .then((value) async {
                  if (value.link != null) {
                    subs.addAll({
                      BetterPlayerSubtitlesSource(
                          name: supportedLanguages[foundIndex].englishName,
                          urls: [value.link],
                          selectedByDefault: true,
                          type: BetterPlayerSubtitlesSourceType.network)
                    });
                  }
                });
              }
            });
          }
        });
      }
    } on Exception catch (e) {
      GlobalMethods.showErrorScaffoldMessengerGeneral(e, context);
    }
  }

  void getAppLanguage() {
    for (int i = 0; i < supportedLanguages.length; i++) {
      if (supportedLanguages[i].languageCode ==
          settings.defaultSubtitleLanguage) {
        foundIndex = i;
        break;
      }
    }
  }

  Future<void> _fetchMovieRecommendations() async {
    try {
      if (widget.metadata.movieId != null) {
        final isProxyEnabled =
            Provider.of<SettingsProvider>(context, listen: false).enableProxy;
        final proxyUrl =
            Provider.of<AppDependencyProvider>(context, listen: false)
                .tmdbProxy;

        // Fetch movie recommendations
        await fetchMovies(
          Endpoints.getMovieRecommendations(
              widget.metadata.movieId!, 1, settings.appLanguage),
          isProxyEnabled,
          proxyUrl,
        ).then((movies) {
          debugPrint('Fetched ${movies.length} movie recommendations');
          if (movies.isNotEmpty) {
            setState(() {
              // Get top 10 recommendations
              final topRecommendations = movies.take(10).toList();
              widget.metadata.recommendations = topRecommendations
                  .map((movie) => MovieRecommendation.fromMovie(movie))
                  .toList();
              debugPrint(
                  'Set ${widget.metadata.recommendations?.length} recommendations in metadata');
            });
          }
        });

        // Set the movie change callback
        widget.metadata.onMovieChange = (int movieId) async {
          // This will be called from the player when user selects a movie
        };
      }
    } catch (e) {
      // If fetching recommendations fails, continue without them
      debugPrint('Failed to fetch movie recommendations: $e');
    }
  }
}

            });
          }

          if (episode != null &&
              episode!.id != null &&
              episode!.id!.isNotEmpty &&
              episode!.episodeId != null &&
              episode!.episodeId!.isNotEmpty) {
            await getMovieStreamLinksAndSubsFlixHQ(
                    Endpoints.getMovieTVStreamLinksTMDB(
                        appDep.consumetUrl,
                        episode!.episodeId!,
                        episode!.id!,
                        appDep.streamingServerFlixHQ))
                .then((value) {
              if (mounted) {
                if (value.messageExists == null &&
                    value.videoLinks != null &&
                    value.videoLinks!.isNotEmpty) {
                  setState(() {
                    fqMovieVideoSources = value;
                  });
                } else if (value.messageExists != null ||
                    value.videoLinks == null ||
                    value.videoLinks!.isEmpty) {
                  return;
                }
              }
              if (mounted) {
                movieVideoLinks = fqMovieVideoSources!.videoLinks;
                movieVideoSubs = fqMovieVideoSources!.videoSubtitles;
                if (movieVideoLinks != null && movieVideoLinks!.isNotEmpty) {
                  convertVideoLinks(movieVideoLinks!);
                }
              }
            });
          }
        });
      }
    } on Exception catch (e) {
      GlobalMethods.showErrorScaffoldMessengerMediaLoad(e, context, 'FlixHQ');
    }
  }

  Future<void> loadNewFlixHQ() async {
    try {
      if (mounted) {
        await getMovieStreamLinksAndSubsFlixHQNew(
            Endpoints.getMovieStreamLinkFlixhqNew(
          appDep.newFlixHQUrl,
          widget.metadata.movieId!,
          appDep.newFlixhqServer,
        )).then((value) {
          if (mounted) {
            if (value.messageExists == null &&
                value.videoLinks != null &&
                value.videoLinks!.isNotEmpty) {
              setState(() {
                fqNewVideoSources = value;
              });
            } else if (value.messageExists != null ||
                value.videoLinks == null ||
                value.videoLinks!.isEmpty) {
              return;
            }
          }
          if (mounted) {
            movieVideoLinks = fqNewVideoSources!.videoLinks;
            movieVideoSubs = fqNewVideoSources!.videoSubtitles;
            if (movieVideoLinks != null && movieVideoLinks!.isNotEmpty) {
              convertVideoLinks(movieVideoLinks!);
            }
          }
        });
      }
    } on Exception catch (e) {
      GlobalMethods.showErrorScaffoldMessengerMediaLoad(
          e, context, 'FlixHQNew');
    }
  }

  Future<void> loadFlixAPI() async {
    try {
      if (mounted) {
        await getMovieTVStreamLinksAndSubsFlixAPI(
                Endpoints.getMovieStreamLinkFlixAPI(
                    appDep.flixApiUrl, widget.metadata.movieId!))
            .then((value) {
          if (mounted) {
            if (value.success &&
                value.stream != null &&
                value.stream!.playlist != null) {
              setState(() {
                flixApiSources = value;
              });
            } else if (!value.success ||
                value.stream == null ||
                value.stream!.playlist == null) {
              return;
            }
          }
          if (mounted) {
            movieVideoLinks = [
              RegularVideoLinks(
                  url: flixApiSources!.stream!.playlist,
                  isM3U8: flixApiSources!.stream!.playlist!.endsWith('.m3u8'))
            ];
            movieVideoSubs = flixApiSources!.stream!.captions
                ?.map((caption) => RegularSubtitleLinks(
                      url: caption.url,
                      language: caption.language,
                    ))
                .toList();
            if (movieVideoLinks != null && movieVideoLinks!.isNotEmpty) {
              convertVideoLinks(movieVideoLinks!);
            }
          }
        });
      }
    } on Exception catch (e) {
      GlobalMethods.showErrorScaffoldMessengerMediaLoad(e, context, 'FlixAPI');
    }
  }

  Future<void> loadDramacool() async {
    try {
      if (mounted) {
        await fetchMovieTVForStreamDCVA(
                Endpoints.searchMovieTVForStreamDramacool(
                    normalizeTitle(widget.metadata.movieName!).toLowerCase(),
                    appDep.consumetUrl))
            .then((value) async {
          if (mounted) {
            setState(() {
              dcMovies = value;
            });
          }

          if (dcMovies == null || dcMovies!.isEmpty) {
            return;
          }

          for (int i = 0; i < dcMovies!.length; i++) {
            if (normalizeTitle(dcMovies![i].title!).toLowerCase().contains(
                    normalizeTitle(widget.metadata.movieName!.toString())
                        .toLowerCase()) ||
                dcMovies![i]
                    .title!
                    .contains(widget.metadata.movieName!.toString())) {
              await getMovieTVStreamEpisodesDCVA(
                      Endpoints.getMovieTVStreamInfoDramacool(
                          dcMovies![i].id!, appDep.consumetUrl))
                  .then((value) async {
                setState(() {
                  dcEpi = value;
                });
                if (dcEpi != null && dcEpi!.isNotEmpty) {
                  await getMovieTVStreamLinksAndSubsDCVA(
                          Endpoints.getMovieTVStreamLinksDramacool(
                              dcEpi![0].id!,
                              dcMovies![i].id!,
                              appDep.consumetUrl,
                              appDep.streamingServerDCVA))
                      .then((value) {
                    if (mounted) {
                      if (value.messageExists == null &&
                          value.videoLinks != null &&
                          value.videoLinks!.isNotEmpty) {
                        setState(() {
                          dramacoolVideoSources = value;
                        });
                      } else if (value.messageExists != null ||
                          value.videoLinks == null ||
                          value.videoLinks!.isEmpty) {
                        return;
                      }
                    }
                    if (mounted) {
                      movieVideoLinks = dramacoolVideoSources!.videoLinks;
                      movieVideoSubs = dramacoolVideoSources!.videoSubtitles;
                      if (movieVideoLinks != null &&
                          movieVideoLinks!.isNotEmpty) {
                        convertVideoLinks(movieVideoLinks!);
                      }
                    }
                  });
                }
              });

              break;
            }
          }
        });
      }
    } on Exception catch (e) {
      GlobalMethods.showErrorScaffoldMessengerMediaLoad(
          e, context, 'Dramacool');
    }
  }

  Future<void> loadViewasian() async {
    try {
      if (mounted) {
        await fetchMovieTVForStreamDCVA(
                Endpoints.searchMovieTVForStreamViewasian(
                    normalizeTitle(widget.metadata.movieName!).toLowerCase(),
                    appDep.consumetUrl))
            .then((value) async {
          if (mounted) {
            setState(() {
              vaMovies = value;
            });
          }

          if (vaMovies == null || vaMovies!.isEmpty) {
            return;
          }

          for (int i = 0; i < vaMovies!.length; i++) {
            if (normalizeTitle(vaMovies![i].title!).toLowerCase().contains(
                    normalizeTitle(widget.metadata.movieName!.toString())
                        .toLowerCase()) ||
                vaMovies![i]
                    .title!
                    .contains(widget.metadata.movieName!.toString())) {
              await getMovieTVStreamEpisodesDCVA(
                      Endpoints.getMovieTVStreamInfoViewasian(
                          vaMovies![i].id!, appDep.consumetUrl))
                  .then((value) async {
                setState(() {
                  vaEpi = value;
                });
                if (vaEpi != null && vaEpi!.isNotEmpty) {
                  await getMovieTVStreamLinksAndSubsDCVA(
                          Endpoints.getMovieTVStreamLinksViewasian(
                              vaEpi![0].id!,
                              vaMovies![i].id!,
                              appDep.consumetUrl,
                              appDep.streamingServerDCVA))
                      .then((value) {
                    if (mounted) {
                      if (value.messageExists == null &&
                          value.videoLinks != null &&
                          value.videoLinks!.isNotEmpty) {
                        setState(() {
                          viewasianVideoSources = value;
                        });
                      } else if (value.messageExists != null ||
                          value.videoLinks == null ||
                          value.videoLinks!.isEmpty) {
                        return;
                      }
                    }
                    if (mounted) {
                      movieVideoLinks = viewasianVideoSources!.videoLinks;
                      movieVideoSubs = viewasianVideoSources!.videoSubtitles;
                      if (movieVideoLinks != null &&
                          movieVideoLinks!.isNotEmpty) {
                        convertVideoLinks(movieVideoLinks!);
                      }
                    }
                  });
                }
              });

              break;
            }
          }
        });
      }
    } on Exception catch (e) {
      GlobalMethods.showErrorScaffoldMessengerMediaLoad(
          e, context, 'ViewAsian');
    }
  }

  Future<void> loadFlixHQNormalRoute() async {
    try {
      if (mounted) {
        await fetchMoviesForStreamFlixHQ(Endpoints.searchMovieTVForStreamFlixHQ(
                normalizeTitle(widget.metadata.movieName!).toLowerCase(),
                appDep.consumetUrl))
            .then((value) async {
          if (mounted) {
            setState(() {
              fqMovies = value;
            });
          }

          if (fqMovies == null || fqMovies!.isEmpty) {
            return;
          }
          bool entryFound = false;
          for (int i = 0; i < fqMovies!.length; i++) {
            if (fqMovies![i].releaseDate ==
                    widget.metadata.releaseYear!.toString() &&
                fqMovies![i].type == 'Movie' &&
                (normalizeTitle(fqMovies![i].title!).toLowerCase().contains(
                        normalizeTitle(widget.metadata.movieName!)
                            .toLowerCase()) ||
                    fqMovies![i]
                        .title!
                        .contains(widget.metadata.movieName!.toString()))) {
              entryFound = true;
              await getMovieStreamEpisodesFlixHQ(
                      Endpoints.getMovieTVStreamInfoFlixHQ(
                          fqMovies![i].id!, appDep.consumetUrl))
                  .then((value) async {
                setState(() {
                  fqEpi = value;
                });
                if (fqEpi != null && fqEpi!.isNotEmpty) {
                  await getMovieStreamLinksAndSubsFlixHQ(
                          Endpoints.getMovieTVStreamLinksFlixHQ(
                              fqEpi![0].id!,
                              fqMovies![i].id!,
                              appDep.consumetUrl,
                              appDep.streamingServerFlixHQ))
                      .then((value) {
                    if (mounted) {
                      if (value.messageExists == null &&
                          value.videoLinks != null &&
                          value.videoLinks!.isNotEmpty) {
                        setState(() {
                          fqMovieVideoSources = value;
                        });
                      } else if (value.messageExists != null ||
                          value.videoLinks == null ||
                          value.videoLinks!.isEmpty) {
                        return;
                      }
                    }

                    if (mounted) {
                      movieVideoLinks = fqMovieVideoSources!.videoLinks;
                      movieVideoSubs = fqMovieVideoSources!.videoSubtitles;
                      if (movieVideoLinks != null &&
                          movieVideoLinks!.isNotEmpty) {
                        convertVideoLinks(movieVideoLinks!);
                      }
                    }
                  });
                }
              });

              break;
            }
          }
          if (!entryFound) {
            throw NotFoundException();
          }
        });
      }
    } on Exception catch (e) {
      GlobalMethods.showErrorScaffoldMessengerMediaLoad(e, context, 'FlixHQ');
    }
  }

  Future<void> loadZoro() async {
    try {
      if (mounted) {
        await fetchMovieTVForStreamZoro(Endpoints.searchZoroMoviesTV(
          appDep.consumetUrl,
          normalizeTitle(widget.metadata.movieName!).toLowerCase(),
        )).then((value) async {
          if (mounted) {
            setState(() {
              zoroMovies = value;
            });
          }

          if (zoroMovies == null || zoroMovies!.isEmpty) {
            return;
          }

          for (int i = 0; i < zoroMovies!.length; i++) {
            if ((normalizeTitle(zoroMovies![i].title!).toLowerCase().contains(
                        widget.metadata.movieName!.toString().toLowerCase()) ||
                    zoroMovies![i]
                        .title!
                        .contains(widget.metadata.movieName!.toString())) &&
                zoroMovies![i].type == 'MOVIE') {
              await getMovieTVStreamEpisodesZoro(Endpoints.getMovieTVInfoZoro(
                      appDep.consumetUrl, zoroMovies![i].id!))
                  .then((value) async {
                setState(() {
                  zoroEpi = value;
                });
                if (zoroEpi != null && zoroEpi!.isNotEmpty) {
                  await getMovieTVStreamLinksAndSubsZoro(
                          Endpoints.getMovieTVStreamLinksZoro(
                              appDep.consumetUrl,
                              zoroEpi![0].id!,
                              appDep.streamingServerZoro))
                      .then((value) {
                    if (mounted) {
                      if (value.messageExists == null &&
                          value.videoLinks != null &&
                          value.videoLinks!.isNotEmpty) {
                        setState(() {
                          zoroVideoSources = value;
                        });
                      } else if (value.messageExists != null ||
                          value.videoLinks == null ||
                          value.videoLinks!.isEmpty) {
                        return;
                      }
                    }
                    if (mounted) {
                      movieVideoLinks = zoroVideoSources!.videoLinks;
                      movieVideoSubs = zoroVideoSources!.videoSubtitles;
                      if (movieVideoLinks != null &&
                          movieVideoLinks!.isNotEmpty) {
                        convertVideoLinks(movieVideoLinks!);
                      }
                    }
                  });
                }
              });

              break;
            }
          }
        });
      }
    } on Exception catch (e) {
      GlobalMethods.showErrorScaffoldMessengerMediaLoad(e, context, 'Zoro');
    }
  }

  Future<void> _fetchMovieRecommendations() async {
    try {
      if (widget.metadata.movieId != null) {
        final isProxyEnabled =
            Provider.of<SettingsProvider>(context, listen: false).enableProxy;
        final proxyUrl =
            Provider.of<AppDependencyProvider>(context, listen: false)
                .tmdbProxy;

        // Fetch movie recommendations
        await fetchMovies(
          Endpoints.getMovieRecommendations(
              widget.metadata.movieId!, 1, settings.appLanguage),
          isProxyEnabled,
          proxyUrl,
        ).then((movies) {
          debugPrint('Fetched ${movies.length} movie recommendations');
          if (movies.isNotEmpty) {
            setState(() {
              // Get top 10 recommendations
              final topRecommendations = movies.take(10).toList();
              widget.metadata.recommendations = topRecommendations
                  .map((movie) => MovieRecommendation.fromMovie(movie))
                  .toList();
              debugPrint(
                  'Set ${widget.metadata.recommendations?.length} recommendations in metadata');
            });
          }
        });

        // Set the movie change callback
        widget.metadata.onMovieChange = (int movieId) async {
          // This will be called from the player when user selects a movie
        };
      }
    } catch (e) {
      // If fetching recommendations fails, continue without them
      debugPrint('Failed to fetch movie recommendations: $e');
    }
  }
}
